#ifndef SHADOWS
#define SHADOWS

#ifdef _RECEIVE_SHADOWS
layout(std140) struct ShadowData
{
    mat4x4 LightViewProjMatrix;
};

layout(std140) uniform Shadows
{
    ShadowData _DirLightShadow;
    ShadowData _SpotLightShadows[MAX_SPOT_LIGHT_SOURCES];
};

uniform sampler2D _DirLightShadowMap;
uniform sampler2DArray _SpotLightShadowMapArray;

bool isFragVisible(float fragZ)
{
    return fragZ >= 0 && fragZ <= 1;
}

bool isShadowed(float fragZ, float shadowMapDepth, float lightAngleCos)
{
    float bias = max(0.005 * (1 - lightAngleCos), 0.0005);
    return shadowMapDepth < fragZ - bias;
}
#endif

float getDirLightShadowTerm(vec3 posWS, float lightAngleCos)
{
    #ifdef _RECEIVE_SHADOWS
    vec4 shadowCoord = _DirLightShadow.LightViewProjMatrix * vec4(posWS, 1);
    float depth = texture(_DirLightShadowMap, shadowCoord.xy).x;
    if (isFragVisible(shadowCoord.z) && isShadowed(shadowCoord.z, depth, lightAngleCos))
        return 0;
    #endif
    return 1;
}

float getSpotLightShadowTerm(int index, vec3 posWS, float lightAngleCos)
{
    #ifdef _RECEIVE_SHADOWS
    vec4 shadowCoord = _SpotLightShadows[index].LightViewProjMatrix * vec4(posWS, 1);
    shadowCoord = shadowCoord / shadowCoord.w;
    float depth = texture(_SpotLightShadowMapArray, vec3(shadowCoord.xy, index)).x;
    if (isFragVisible(shadowCoord.z) && isShadowed(shadowCoord.z, depth, lightAngleCos))
        return 0;
    #endif
    return 1;
}

#endif